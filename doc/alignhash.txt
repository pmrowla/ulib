The use of aligned hashings is similiar to STL's hash_map/hash_set
class. So here I just write down major differences.

align_hash_map for example, requires two template parameters as Key
and Value types. Unlike STL's hash_map, where additional euqual
function and hasher can be provided, align_hash_map doesn't
have such parameters. These two functionalities are expected to be
part of Key classes, that is, == operator and size_t operator.

Another change worthy of note is the iterator. In STL-like Key-Value
containers, two members first and second are respectively refered as
Key and Value. While align_hash_map and align_hash_set don't follow
this rule for memory saving purpose. Instead, Key and Values are
refered by key() and value() member functions of iterator.

Two probing method are available in alignhash, linear probing and tier
probing. Linear probing is the default choice which is optimized for
excessive lookups, or when there are a lot of key-value pairs. Tier
probing, on the other hand, adopts additional hashing to achieve
enhanced collision resolution. Tier probing shall only be used when
keys are not random, e.g., bad/no hash function is used.

For sample use, please check test_alignhash.cpp in test/.
