===========================================================================
	Introducting ULIB
===========================================================================

1. What is ULIB?
   ULIB is a collection of efficient and flexible implementations of
   common data structures and algorithms. The essential part of ULIB
   is written in C, that is, the 'core'. Other parts of the library act
   as extensions to the 'core'.

2. What it is good for?
   There are mainly two advantages of ULIB over many other libraries,
   performance and interface. ULIB is well implemented and has better
   or similar performance as compared to state-of-the-art
   libraries. In addition, the APIs of ULIB is carefully designed and
   largely follow the kernel coding style paradigm - simple and flexible.

===========================================================================
	Layout of the Source Tree
===========================================================================
   As usual, the output is divided into includes and libraries, which
   are respectively resides into include/ and lib/
   directories. According  to their functionalities, the source is
   structured in layers, where layers with higher levels use make
   use of the lower level layers. Each layer writes its output
   independently into include/ and lib/, when all sources are
   compiled, the libraries of all layers are merged into a single
   library. 

===========================================================================
	Core Components
===========================================================================

1. Aligned Hashing
   Aligned hashing is an extremely efficient hashing scheme. Both Map and
   Set are provided in alignhash.h. The properties of aligned
   hashing are:
   1) CPU cache-conscious layout. A bitmap index is used to support fast
      data location especially for sparse key distributions.
   2) Aligned data access. The bucket for a set/search operation is
      located through logical AND not %. This implies a significant
      improvement on searching.
   3) Tier-probing, a technique based on double hashing.

2. Data Structures
   1) Ported linux kernel list, a simple doubly linked list implementation.
   2) Various trees, including binary search tree, splay tree, red-black
      tree and AVL tree.
   3) Bitmap.

3. Search Algorithms
   1) File binary search algorithm, which performs a binary search on
   a line-sorted file for lines that meet the conditions given by the
   user-defined function.
   2) Median algorithm.

4. Sorting Algorithms
   1) List merge-sort algorthm.

5. Cryptographic Algorithms
   1) AES (Advanced Encryption Standard)

6. Math tools.
   1) GCD algorithm.

7. Utilities.
   1) String utilities, splitting, parsing etc.
   2) A high resolution timer.
   3) A collection of hash functions.
   4) A hexdump utility.
